require({cache:{
'url:esri/views/3d/webgl-engine/materials/internal/highlight.xml':"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<snippets>\n\n<!--\n===============================================================================\nSmartly downsamples a texture, halfing its resolution. This allows for a square\nscreen region to check if none, any or all pixels were set.\n\nThe red channel is always ceiled after interpolating the 4 merged pixels.\nThis allows to evaluate:\nany(pixels.red != 0.0) as red == 1.0\nnone(pixels.red != 0.0) as red == 0.0\n\nThe green and blue channels are set to floor(max(green, blue)).\nThis allows to evaluate:\nall(pixels.green || pixels.blue) as green == 1.0\n===============================================================================\n-->\n\n<snippet name=\"vsConservativeDownsample\"><![CDATA[\n\n  $vsprecisionf\n\n  attribute vec2 $position;\n\n  void main()\n  {\n    gl_Position = vec4(vec2(1.0) - $position * 2.0, .0, 1.0);\n  }\n]]></snippet>\n\n<snippet name=\"fsConservativeDownsample\"><![CDATA[\n\n  $fsprecisionf\n\n  uniform sampler2D tex;\n  uniform vec2 invFramebufferDim;\n\n  void main()\n  {\n    vec2 coord = gl_FragCoord.xy * invFramebufferDim;\n    vec4 value = texture2D(tex, coord);\n    float mx = floor(max(value.g, value.b));\n    gl_FragColor = vec4(ceil(value.r), mx, mx, 1.0);\n  }\n]]></snippet>\n\n<!--\n===============================================================================\nGaussian blur with linear sampling. Supports different number of samples, but\nonly 5 samples have proper weights. Uses linear texture interpolation to reduce\nthe number of samples taken.\n\nDefines:\nGRID_OPTIMIZATION (set or !set)\nGAUSSIAN_SAMPLES (3,5,7)\n\nThis technique requires linear filtering on source texture\nhttp://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\n===============================================================================\n-->\n<snippet name=\"vsHighlightBlurFastGaussian\"><![CDATA[\n\n  $vsprecisionf\n\n  attribute vec2 $position;\n  attribute vec2 $uv0;\n\n  #ifdef GRID_OPTIMIZATION\n    uniform sampler2D coverageTex;\n    varying vec3 blurCoordinate;\n  #else\n    uniform vec2 blurSize;\n    varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n  #endif\n\n  void main()\n  {\n    gl_Position = vec4($position, 0.0, 1.0);\n\n    #ifdef GRID_OPTIMIZATION\n      // sample the coverage texture at the block center\n      // and if no coverage detected, create degenerate triangle\n      vec4 cov = texture2D(coverageTex, $uv0);\n      if (cov.r == 0.0) {\n        gl_Position = vec4(0,0,0,0);\n      }\n\n      // create texture coordinate for blur center\n      // encode information about fully inside block in z coordinate\n      blurCoordinate = vec3(gl_Position.xy * .5 + vec2(.5), max(cov.g, cov.b));\n    #else\n      vec2 uv = $position.xy * .5 + vec2(.5);\n\n      #if GAUSSIAN_SAMPLES == 3\n        // not proper gaussian weights\n        blurCoordinates[0] = uv;\n        blurCoordinates[1] = uv + blurSize * 1.407333;\n        blurCoordinates[2] = uv - blurSize * 1.407333;\n      #elif GAUSSIAN_SAMPLES == 5\n        blurCoordinates[0] = uv;\n        blurCoordinates[1] = uv + blurSize * 1.407333;\n        blurCoordinates[2] = uv - blurSize * 1.407333;\n        blurCoordinates[3] = uv + blurSize * 3.294215;\n        blurCoordinates[4] = uv - blurSize * 3.294215;\n      #elif GAUSSIAN_SAMPLES == 7\n        // not proper gaussian weights\n        blurCoordinates[0] = uv;\n        blurCoordinates[1] = uv + blurSize * 1.407333;\n        blurCoordinates[2] = uv - blurSize * 1.407333;\n        blurCoordinates[3] = uv + blurSize * 3.294215;\n        blurCoordinates[4] = uv - blurSize * 3.294215;\n        blurCoordinates[5] = uv + blurSize * 5.1;\n        blurCoordinates[6] = uv - blurSize * 5.1;\n      #elif GAUSSIAN_SAMPLES == 9\n        // not proper gaussian weights\n        blurCoordinates[0] = uv;\n        blurCoordinates[1] = uv + blurSize * 1.407333;\n        blurCoordinates[2] = uv - blurSize * 1.407333;\n        blurCoordinates[3] = uv + blurSize * 3.294215;\n        blurCoordinates[4] = uv - blurSize * 3.294215;\n        blurCoordinates[5] = uv + blurSize * 5.1;\n        blurCoordinates[6] = uv - blurSize * 5.1;\n        blurCoordinates[7] = uv + blurSize * 7.1;\n        blurCoordinates[8] = uv - blurSize * 7.1;\n      #endif\n    #endif\n  }\n]]></snippet>\n\n<snippet name=\"fsHighlightBlurFastGaussian\"><![CDATA[\n\n  $fsprecisionf\n\n  uniform sampler2D tex;\n\n  #ifdef GRID_OPTIMIZATION\n    uniform vec2 blurSize;\n    varying vec3 blurCoordinate;\n  #else\n    varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n  #endif\n\n  void main()\n  {\n    #ifdef GRID_OPTIMIZATION\n      vec2 uv = blurCoordinate.xy;\n      vec4 center = texture2D(tex, uv);\n\n      // do not blur if no pixel or all pixels in neighborhood are set\n      if (blurCoordinate.z == 1.0) {\n        gl_FragColor = center;\n      }\n      else {\n        vec4 sum = vec4(0.0);\n\n        #if GAUSSIAN_SAMPLES == 3\n          // not proper gaussian weights\n          sum += center * 0.204164;\n          sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n          sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n        #elif GAUSSIAN_SAMPLES == 5\n          sum += center * 0.204164;\n          sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n          sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n          sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n          sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n        #elif GAUSSIAN_SAMPLES == 7\n          // not proper gaussian weights\n          sum += center * 0.204164;\n          sum += texture2D(tex, uv + blurSize * 1.407333) * 0.304005;\n          sum += texture2D(tex, uv - blurSize * 1.407333) * 0.304005;\n          sum += texture2D(tex, uv + blurSize * 3.294215) * 0.093913;\n          sum += texture2D(tex, uv - blurSize * 3.294215) * 0.093913;\n          sum += texture2D(tex, uv + blurSize * 5.1) * 0.03;\n          sum += texture2D(tex, uv - blurSize * 5.1) * 0.03;\n        #elif GAUSSIAN_SAMPLES == 9\n          // not proper gaussian weights\n          sum += center * 0.154164;\n          sum += texture2D(tex, uv + blurSize * 1.5) * 0.204005;\n          sum += texture2D(tex, uv - blurSize * 1.5) * 0.204005;\n          sum += texture2D(tex, uv + blurSize * 3.5) * 0.123913;\n          sum += texture2D(tex, uv - blurSize * 3.5) * 0.123913;\n          sum += texture2D(tex, uv + blurSize * 5.5) * 0.123913;\n          sum += texture2D(tex, uv - blurSize * 5.5) * 0.123913;\n          sum += texture2D(tex, uv + blurSize * 7.5) * 0.05;\n          sum += texture2D(tex, uv - blurSize * 7.5) * 0.05;\n        #endif\n\n        gl_FragColor = sum;\n      }\n    #else\n      vec4 sum = vec4(0.0);\n\n      #if GAUSSIAN_SAMPLES == 3\n        // not proper gaussian weights\n        sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n        sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n        sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n      #elif GAUSSIAN_SAMPLES == 5\n        sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n        sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n        sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n        sum += texture2D(tex, blurCoordinates[3]) * 0.093913;\n        sum += texture2D(tex, blurCoordinates[4]) * 0.093913;\n      #elif GAUSSIAN_SAMPLES == 7\n        // not proper gaussian weights\n        sum += texture2D(tex, blurCoordinates[0]) * 0.204164;\n        sum += texture2D(tex, blurCoordinates[1]) * 0.304005;\n        sum += texture2D(tex, blurCoordinates[2]) * 0.304005;\n        sum += texture2D(tex, blurCoordinates[3]) * 0.093913;\n        sum += texture2D(tex, blurCoordinates[4]) * 0.093913;\n        sum += texture2D(tex, blurCoordinates[5]) * 0.03;\n        sum += texture2D(tex, blurCoordinates[6]) * 0.03;\n      #elif GAUSSIAN_SAMPLES == 9\n        // not proper gaussian weights\n        sum += texture2D(tex, blurCoordinates[0]) * 0.154164;\n        sum += texture2D(tex, blurCoordinates[1]) * 0.204005;\n        sum += texture2D(tex, blurCoordinates[2]) * 0.204005;\n        sum += texture2D(tex, blurCoordinates[3]) * 0.123913;\n        sum += texture2D(tex, blurCoordinates[4]) * 0.123913;\n        sum += texture2D(tex, blurCoordinates[5]) * 0.09;\n        sum += texture2D(tex, blurCoordinates[6]) * 0.09;\n        sum += texture2D(tex, blurCoordinates[7]) * 0.05;\n        sum += texture2D(tex, blurCoordinates[8]) * 0.05;\n      #endif\n\n      gl_FragColor = sum;\n    #endif\n  }\n]]></snippet>\n\n<!--\n===============================================================================\nMerging blurred outlines with source image, advanced version\n\nDefines:\nGRID_OPTIMIZATION (set or !set)\nGRID_DEBUG (set or !set)\n===============================================================================\n-->\n<snippet name=\"vsHighlightApply\"><![CDATA[\n\n  $vsprecisionf\n\n  attribute vec2 $position;\n  varying vec2 uv;\n\n  #ifdef GRID_OPTIMIZATION\n    attribute vec2 $uv0;\n    uniform sampler2D coverageTex;\n  #endif\n\n  void main()\n  {\n    #ifdef GRID_OPTIMIZATION\n      #ifdef GRID_DEBUG\n        vec4 cov = texture2D(coverageTex, $uv0);\n        // if no highlight pixel set in this block,\n        // or all pixels set, hide block\n        if (cov.r == 0.0 || cov.g == 1.0 || cov.b == 1.0) {\n          gl_Position = vec4(0,0,0,0);\n          return;\n        }\n        gl_Position = vec4($position, .0, 1.0);\n        uv = $uv0;\n        return;\n      #else\n        vec4 cov = texture2D(coverageTex, $uv0);\n        // if no highlight pixel set in this block, hide block\n        if (cov.r == 0.0) {\n          gl_Position = vec4(0,0,0,0);\n          return;\n        }\n      #endif\n    #endif\n\n    gl_Position = vec4($position, .0, 1.0);\n    uv = $position.xy * .5 + vec2(.5);\n  }\n]]></snippet>\n\n<snippet name=\"fsHighlightApply\"><![CDATA[\n\n  $fsprecisionf\n\n  uniform sampler2D tex;\n  uniform sampler2D origin;\n\n  uniform vec4 color;\n  uniform float outlineSize;\n  uniform float blurSize;\n  uniform vec4 opacities; // [outline, outlineOccluded, fill, fillOccluded]\n\n  varying vec2 uv;\n\n  void main()\n  {\n    #if defined(GRID_OPTIMIZATION) && defined(GRID_DEBUG)\n      gl_FragColor = vec4(uv, 0, 1.0);\n    #else\n      // Read the highlight intensity from the blurred highlight image\n      vec4 blurredHighlightValue = texture2D(tex, uv);\n      float highlightIntensity = blurredHighlightValue.a;\n\n      // Discard all pixels which are not affected by highlight\n      if (highlightIntensity == 0.0) {\n        discard;\n      }\n\n      vec4 origin_color = texture2D(origin, uv);\n\n      float outlineIntensity;\n      float fillIntensity;\n\n      // if occluded\n      if (blurredHighlightValue.g > blurredHighlightValue.b) {\n        outlineIntensity = color.w * opacities[1];\n        fillIntensity = color.w * opacities[3];\n      }\n      // if unoccluded\n      else {\n        outlineIntensity = color.w * opacities[0];\n        fillIntensity = color.w * opacities[2];\n      }\n\n      float inner = 1.0 - outlineSize / 9.0;\n      float outer = 1.0 - (outlineSize + blurSize) / 9.0;\n\n      float outlineFactor = smoothstep(outer, inner, highlightIntensity);\n      //float fillFactor = smoothstep(0.6, 0.72, highlightIntensity);\n      float fillFactor = any(notEqual(origin_color, vec4(0.0, 0.0, 0.0, 0.0))) ? 1.0 : 0.0;\n      float intensity = outlineIntensity * outlineFactor * (1.0 - fillFactor) + fillIntensity * fillFactor;\n\n      // Blending equation: gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n      // I.e., color should not be premultiplied with alpha\n      gl_FragColor = vec4(color.xyz, intensity);\n    #endif\n  }\n]]></snippet>\n\n</snippets>\n"}});
// COPYRIGHT Â© 2017 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.4/esri/copyright.txt for details.

define(["require","exports","./Util","./gl-matrix","dojo/text!../materials/internal/highlight.xml","../../../webgl/FramebufferObject","../../../webgl/Program","../../../webgl/VertexArrayObject","../../../webgl/BufferObject","../../../webgl/Util","../../../webgl/enums","./DefaultVertexBufferLayouts","./DefaultVertexAttributeLocations","../../support/debugFlags"],function(e,t,i,r,l,a,o,h,s,n,p,u,g,d){var c=r.vec4d,b=32,f=8.6,m=.4,v="5",O=function(){function e(e,t,i){this._grid={coverageMipmap:null,vao:null,verticalCellCount:0,horizontalCellCount:0,cellPixelSize:0,mipmapLevels:0,viewportWidth:0,viewportHeight:0},this.quadVAO=null,this.blur0Fbo=null,this.blur1Fbo=null,this._rctx=i,this.viewportToRestore=c.create(),this.programRep=e,this.defaultOptions={color:new Float32Array([1,0,1,1]),haloOpacity:1,fillOpacity:.2,haloOpacityOccluded:.25,fillOpacityOccluded:.05}}return e.prototype._gridUpdateResources=function(e,t){var i=this._rctx,r=this._grid,l=!1;if(null===r.coverageMipmap&&(r.coverageMipmap=[e],l=!0),(r.viewportWidth!==e.width||r.viewportHeight!==e.height)&&(l=!0,r.viewportWidth=e.width,r.viewportHeight=e.height),r.coverageMipmap[0]=e,r.cellPixelSize!==t&&(r.cellPixelSize=t,l=!0),l){for(var o=1;o<r.coverageMipmap.length;o++)r.coverageMipmap[o].dispose();r.mipmapLevels=Math.ceil(Math.log(r.cellPixelSize)*Math.LOG2E),r.coverageMipmap.length=r.mipmapLevels+1;for(var o=0;o<r.mipmapLevels;o++){var n=r.coverageMipmap[o],p={target:3553,pixelFormat:6407,dataType:33635,samplingMode:9729,wrapMode:33071,width:Math.ceil(n.width/2),height:Math.ceil(n.height/2)},d={colorTarget:0,depthStencilTarget:0,width:Math.ceil(n.width/2),height:Math.ceil(n.height/2)},c=a.createWithAttachments(i,p,d);r.coverageMipmap[o+1]=c}}var b=Math.ceil(e.height/r.cellPixelSize),f=Math.ceil(e.width/r.cellPixelSize);if(!r.vao||r.verticalCellCount!==b||r.horizontalCellCount!==f){r.verticalCellCount=b,r.horizontalCellCount=f;for(var m=b+1,v=f+1,O=1/b,w=1/f,y=6,x=4,T=new Float32Array(y*x*m*v),A=0,F=0;m>F;F++)for(var M=0;v>M;M++)T[A+0]=(M-.5)*w*2-1,T[A+1]=(F-.5)*O*2-1,T[A+2]=M*w,T[A+3]=F*O,T[A+4]=(M+.5)*w*2-1,T[A+5]=(F-.5)*O*2-1,T[A+6]=M*w,T[A+7]=F*O,T[A+8]=(M-.5)*w*2-1,T[A+9]=(F+.5)*O*2-1,T[A+10]=M*w,T[A+11]=F*O,T[A+12]=(M-.5)*w*2-1,T[A+13]=(F+.5)*O*2-1,T[A+14]=M*w,T[A+15]=F*O,T[A+16]=(M+.5)*w*2-1,T[A+17]=(F-.5)*O*2-1,T[A+18]=M*w,T[A+19]=F*O,T[A+20]=(M+.5)*w*2-1,T[A+21]=(F+.5)*O*2-1,T[A+22]=M*w,T[A+23]=F*O,A+=y*x;r.vao&&r.vao.dispose(!0),r.vao=new h(i,g.Default3D,{geometry:u.Pos2Tex},{geometry:s.createVertex(i,35044,T)})}},e.prototype._gridComputeMipmap=function(){var e=this._rctx,t=this._grid,i=this.programRep.get("conservative-downsample");e.bindVAO(this.quadVAO);for(var r=0;r<t.mipmapLevels;r++){e.bindFramebuffer(t.coverageMipmap[r+1]),e.bindTexture(t.coverageMipmap[r].colorTexture,0);var l=t.coverageMipmap[r+1].width,a=t.coverageMipmap[r+1].height;e.bindProgram(i),i.setUniform1i("tex",0),i.setUniform2f("invFramebufferDim",1/l,1/a),e.setViewport(0,0,l,a),e.drawArrays(5,0,n.vertexCount(this.quadVAO,"geometry"))}},e.prototype.createQuadVAO=function(){var e=this._rctx,t=new Float32Array([-1,-1,1,-1,-1,1,1,1]);return new h(e,g.Default3D,{geometry:u.Pos2},{geometry:s.createVertex(e,35044,t)})},Object.defineProperty(e.prototype,"profilingCallback",{get:function(){return d.HIGHLIGHTS_PROFILE_TO_CONSOLE?function(e){return  0 && console.log(e)}:null},enumerable:!0,configurable:!0}),e.prototype.getIsSupported=function(){return!0},e.prototype.setEnableState=function(e){e?this.enable():this.disable()},e.prototype.getEnableState=function(){return null!==this.blur0Fbo},e.prototype.enable=function(){this.quadVAO=this.createQuadVAO();var e={colorTarget:0,depthStencilTarget:0,width:0,height:0},t={target:3553,pixelFormat:6408,dataType:5121,samplingMode:9729,wrapMode:33071,width:0,height:0};this.blur0Fbo=a.createWithAttachments(this._rctx,t,e),this.blur1Fbo=a.createWithAttachments(this._rctx,t,e)},e.prototype.disable=function(){this.getEnableState()&&(this.quadVAO.dispose(!0),this.blur1Fbo.dispose(),this.blur0Fbo.dispose(),this.quadVAO=null,this.blur0Fbo=null,this.blur1Fbo=null)},e.prototype.getHighlightFBO=function(){return this.blur0Fbo},e.prototype.render=function(e,t,r){var l=1,a=!d.HIGHLIGHTS_GRID_OPTIMIZATION_DISABLED,o=v,h=d.HIGHLIGHTS_VISUALIZE_BLOCKS,s=this._rctx;i.assert(this.getEnableState()),c.set(e.fullViewport,this.viewportToRestore);var p=r.width,u=r.height,g=Math.ceil(p/l),O=Math.ceil(u/l);this.blur0Fbo.resize(g,O),this.blur1Fbo.resize(g,O),s.bindVAO(this.quadVAO),s.setDepthWriteEnabled(!1),s.setDepthTestEnabled(!1),s.setBlendingEnabled(!1);var w=null,y=null,x=null,T=null;if(a){var A=this._grid;this._gridUpdateResources(r,b),this._gridComputeMipmap(),x=A.vao,T=4,w=this.programRep.get("highlight-blur-grid-"+o),s.bindProgram(w),s.bindTexture(A.coverageMipmap[A.mipmapLevels].colorTexture,1),w.setUniform1i("coverageTex",1)}else x=this.quadVAO,T=5,w=this.programRep.get("highlight-blur-"+o),s.bindProgram(w);if(s.bindVAO(x),s.bindFramebuffer(this.blur0Fbo),s.setViewport(0,0,g,O),s.setClearColor(0,0,0,0),s.clear(s.gl.COLOR_BUFFER_BIT),w.setUniform1i("tex",0),s.bindTexture(r.colorTexture,0),w.setUniform2f("blurSize",1/g,0),s.drawArrays(T,0,n.vertexCount(x,"geometry")),s.bindFramebuffer(this.blur1Fbo),s.clear(s.gl.COLOR_BUFFER_BIT),s.bindTexture(this.blur0Fbo.colorTexture,0),w.setUniform2f("blurSize",0,1/O),s.drawArrays(T,0,n.vertexCount(x,"geometry")),s.bindFramebuffer(t),s.setBlendingEnabled(!0),s.setBlendFunctionSeparate(770,771,1,771),s.setViewport(this.viewportToRestore[0],this.viewportToRestore[1],this.viewportToRestore[2],this.viewportToRestore[3]),a){y=this.programRep.get(h?"highlight-apply-grid-debug":"highlight-apply-grid"),s.bindProgram(y),y.setUniform1i("coverageTex",2);var F=this._grid.coverageMipmap[this._grid.mipmapLevels].colorTexture;s.bindTexture(F,2)}else y=this.programRep.get("highlight-apply"),s.bindProgram(y);y.setUniform1i("tex",0),s.bindTexture(this.blur1Fbo.colorTexture,0),y.setUniform1i("origin",1),s.bindTexture(r.colorTexture,1),y.setUniform4fv("color",this.defaultOptions.color),y.setUniform1f("outlineSize",f),y.setUniform1f("blurSize",m),y.setUniform4f("opacities",this.defaultOptions.haloOpacity,this.defaultOptions.haloOpacityOccluded,this.defaultOptions.fillOpacity,this.defaultOptions.fillOpacityOccluded),s.drawArrays(T,0,n.vertexCount(x,"geometry")),s.bindVAO(null),s.setDepthWriteEnabled(!0),s.setDepthTestEnabled(!0),s.setBlendingEnabled(!1)},e.prototype.setDefaultOptions=function(e){this.defaultOptions=e},e.loadShaders=function(e,t,i,r){e._parse(l);for(var a=0,h=["3","5","7","9"];a<h.length;a++){var s=h[a];i.add("highlight-blur-"+s,new o(r,e.vsHighlightBlurFastGaussian,e.fsHighlightBlurFastGaussian,g.Default3D,{GAUSSIAN_SAMPLES:s})),i.add("highlight-blur-grid-"+s,new o(r,e.vsHighlightBlurFastGaussian,e.fsHighlightBlurFastGaussian,g.Default3D,{GAUSSIAN_SAMPLES:s,GRID_OPTIMIZATION:"true"}))}i.add("highlight-apply",new o(r,e.vsHighlightApply,e.fsHighlightApply,g.Default3D)),i.add("highlight-apply-grid",new o(r,e.vsHighlightApply,e.fsHighlightApply,g.Default3D,["GRID_OPTIMIZATION"])),i.add("highlight-apply-grid-debug",new o(r,e.vsHighlightApply,e.fsHighlightApply,g.Default3D,["GRID_OPTIMIZATION","GRID_DEBUG"])),i.add("conservative-downsample",new o(r,e.vsConservativeDownsample,e.fsConservativeDownsample,g.Default3D))},e}();return O});